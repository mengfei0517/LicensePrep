<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPS Route Recorder (Leaflet)</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8f9fa;
        }

        .recorder-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            margin: 0;
            font-size: 1.8em;
        }

        .close-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .map-container {
            position: relative;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        #map {
            width: 100%;
            height: 500px;
            border-radius: 10px;
            position: relative;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .control-btn {
            flex: 1;
            min-width: 150px;
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .start-btn {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
        }

        .start-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(17, 153, 142, 0.4);
        }

        .stop-btn {
            background: linear-gradient(135deg, #ee0979 0%, #ff6a00 100%);
            color: white;
        }

        .stop-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(238, 9, 121, 0.4);
        }

        .save-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .save-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .status-panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .status-item:last-child {
            border-bottom: none;
        }

        .status-label {
            font-weight: 600;
            color: #495057;
        }

        .status-value {
            color: #667eea;
            font-weight: 600;
        }

        .recording-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            background: #ee0979;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
            margin-right: 8px;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.5;
                transform: scale(1.2);
            }
        }

        /* Pulsing marker CSS */
        .pulsing-marker {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #ee0979;
            position: relative;
            box-shadow: 0 0 0 rgba(238, 9, 121, 0.4);
            animation: marker-pulse 2s infinite;
        }

        @keyframes marker-pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(238, 9, 121, 0.7);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(238, 9, 121, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(238, 9, 121, 0);
            }
        }

        .info-banner {
            background: #e7f3ff;
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            color: #2c5282;
        }

        .info-banner strong {
            color: #667eea;
        }

        /* Voice Notes Styles */
        .voice-notes-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            margin-top: 20px;
        }

        .voice-notes-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }

        .voice-notes-header h3 {
            margin: 0;
            color: #495057;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .voice-record-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .voice-record-btn.ready {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .voice-record-btn.recording {
            background: linear-gradient(135deg, #ee0979 0%, #ff6a00 100%);
            color: white;
            animation: pulse-btn 1.5s infinite;
        }

        .voice-record-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        @keyframes pulse-btn {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .voice-notes-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .voice-note-item {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .voice-note-item:hover {
            background: #e9ecef;
            transform: translateX(5px);
        }

        .voice-note-info {
            flex: 1;
        }

        .voice-note-time {
            font-size: 0.9em;
            color: #667eea;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .voice-note-location {
            font-size: 0.85em;
            color: #6c757d;
        }

        .voice-note-actions {
            display: flex;
            gap: 10px;
        }

        .voice-action-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .voice-action-btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }

        .voice-action-btn.delete {
            background: #ee0979;
        }

        .voice-action-btn.delete:hover {
            background: #d60865;
        }

        .empty-voice-notes {
            text-align: center;
            padding: 40px;
            color: #6c757d;
        }

        .empty-voice-notes-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }

        .mic-permission-banner {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            color: #856404;
            display: none;
        }

        .mic-permission-banner.show {
            display: block;
        }

        .mic-permission-banner strong {
            color: #ffc107;
        }

        .voice-recording-timer {
            display: inline-block;
            margin-left: 10px;
            font-family: monospace;
            font-size: 1.1em;
        }
    </style>
</head>
<body>
    <div class="recorder-container">
        <div class="header">
            <h1>üìç GPS Route Recorder</h1>
            <button class="close-btn" onclick="window.close()">Close Window</button>
        </div>

        <div class="info-banner">
            <strong>üó∫Ô∏è Using OpenStreetMap</strong> - Open source maps, no API key required!<br>
            <strong>‚òÅÔ∏è Auto Sync:</strong> Finished sessions (including voice notes & map snapshot) appear automatically on your dashboard.
        </div>

        <div class="map-container" id="map-capture">
            <div id="map"></div>
            
            <div class="controls">
                <button class="control-btn start-btn" id="startBtn">
                    <span>‚ñ∂Ô∏è Start Recording</span>
                </button>
                <button class="control-btn stop-btn" id="stopBtn" disabled>
                    <span id="stopBtnText">‚èπÔ∏è Stop Recording</span>
                </button>
                <button class="control-btn save-btn" id="saveBtn" disabled>
                    <span>üíæ Save Route</span>
                </button>
            </div>
        </div>

        <div class="status-panel">
            <div class="status-item">
                <span class="status-label">Status:</span>
                <span class="status-value" id="statusText">Ready</span>
            </div>
            <div class="status-item">
                <span class="status-label">Points Recorded:</span>
                <span class="status-value" id="pointsCount">0</span>
            </div>
            <div class="status-item">
                <span class="status-label">Duration:</span>
                <span class="status-value" id="duration">00:00:00</span>
            </div>
            <div class="status-item">
                <span class="status-label">Distance:</span>
                <span class="status-value" id="distance">0.00 km</span>
            </div>
        </div>

        <!-- Voice Notes Section -->
        <div class="voice-notes-container">
            <div class="mic-permission-banner" id="micPermissionBanner">
                <strong>üé§ Microphone Permission Required</strong><br>
                Please allow microphone access to record voice notes during your drive.
            </div>

            <div class="voice-notes-header">
                <h3>
                    üéôÔ∏è Voice Notes
                    <span style="font-size: 0.8em; color: #6c757d; font-weight: normal;" id="voiceNotesCount">(0)</span>
                </h3>
                <button class="voice-record-btn ready" id="voiceRecordBtn" disabled>
                    <span id="voiceRecordIcon">üé§</span>
                    <span id="voiceRecordText">Record Note</span>
                    <span class="voice-recording-timer" id="voiceTimer" style="display: none;">0:00</span>
                </button>
            </div>

            <div class="voice-notes-list" id="voiceNotesList">
                <div class="empty-voice-notes">
                    <div class="empty-voice-notes-icon">üéµ</div>
                    <p>No voice notes yet</p>
                    <p style="font-size: 0.9em;">Start recording to add voice notes at any point during your drive</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- html2canvas for screenshot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <script>
        let map;
        let currentMarker;
        let routePath;
        let routeCoordinates = [];
        let recordedPoints = [];
        let isRecording = false;
        let watchId = null;
        let startTime = null;
        let durationInterval = null;
        let totalDistance = 0;
        let sessionId = null;
        let gpsBatch = [];
        let sessionStartIso = null;
        const GPS_BATCH_SIZE = 5;

        const deviceIdentifier = (() => {
            try {
                const stored = localStorage.getItem('webRecorderDeviceId');
                if (stored) return stored;
                const generated = `web-recorder-${crypto.randomUUID()}`;
                localStorage.setItem('webRecorderDeviceId', generated);
                return generated;
            } catch (error) {
                console.warn('Unable to access localStorage for device id:', error);
                return `web-recorder-${Date.now()}`;
            }
        })();

        // Voice notes variables
        let mediaRecorder = null;
        let audioChunks = [];
        let voiceNotes = [];
        let isRecordingVoice = false;
        let voiceRecordingStartTime = null;
        let voiceTimerInterval = null;
        let microphoneStream = null;

        async function createSession() {
            const payload = {
                device_id: deviceIdentifier,
                start_time: new Date().toISOString(),
                source: 'web',
            };

            const response = await fetch('/api/mobile/routes/start', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
            });

            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.error || `Failed to start session (${response.status})`);
            }

            const data = await response.json();
            sessionId = data.session_id;
            sessionStartIso = payload.start_time;
            console.log('[Recorder] Session started:', sessionId);
            return sessionId;
        }

        async function uploadGpsBatch(force = false) {
            if (!sessionId || gpsBatch.length === 0) {
                return;
            }
            if (!force && gpsBatch.length < GPS_BATCH_SIZE) {
                return;
            }

            const batch = [...gpsBatch];
            gpsBatch = [];

            try {
                const response = await fetch(`/api/mobile/routes/${sessionId}/gps`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ points: batch }),
                });

                if (!response.ok) {
                    const error = await response.json().catch(() => ({}));
                    throw new Error(error.error || `GPS upload failed (${response.status})`);
                }

                console.log(`[Recorder] Uploaded ${batch.length} GPS points`);
            } catch (error) {
                console.error('[Recorder] Failed to upload GPS points:', error);
                gpsBatch = batch.concat(gpsBatch); // requeue
            }
        }

        function calculateBounds(points) {
            if (!points.length) return null;
            const lats = points.map(p => p.latitude).filter(v => v !== null && v !== undefined);
            const lngs = points.map(p => p.longitude).filter(v => v !== null && v !== undefined);
            if (!lats.length || !lngs.length) return null;
            return {
                min_lat: Math.min(...lats),
                max_lat: Math.max(...lats),
                min_lng: Math.min(...lngs),
                max_lng: Math.max(...lngs),
            };
        }

        async function finishSession(mapSnapshot) {
            if (!sessionId) throw new Error('Session not started');

            const durationMinutes = startTime ? ((Date.now() - startTime) / 60000) : 0;
            const bounds = calculateBounds(recordedPoints);

            const payload = {
                end_time: new Date().toISOString(),
                total_distance: Number(totalDistance.toFixed(3)),
                total_duration: Number(durationMinutes.toFixed(2)),
                map_snapshot: mapSnapshot || null,
                map_bounds: bounds,
            };

            const response = await fetch(`/api/mobile/routes/${sessionId}/finish`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
            });

            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.error || `Failed to finish session (${response.status})`);
            }

            console.log('[Recorder] Session finished:', sessionId);
            sessionId = null;
            return response.json();
        }

        async function uploadVoiceNoteBlob(blob, location, timestampIso, durationMs) {
            if (!sessionId) {
                throw new Error('Session not started');
            }

            const formData = new FormData();
            formData.append('audio_file', blob, `voice_${Date.now()}.webm`);
            formData.append('timestamp', timestampIso);
            formData.append('latitude', location?.lat?.toString() || '');
            formData.append('longitude', location?.lng?.toString() || '');
            if (typeof durationMs === 'number') {
                formData.append('duration_ms', durationMs.toString());
            }

            const response = await fetch(`/api/mobile/routes/${sessionId}/audio`, {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.error || `Voice note upload failed (${response.status})`);
            }

            console.log('[Recorder] Voice note uploaded.');
        }

        // Initialize map with Leaflet
        function initMap() {
            // Default location (Germany)
            const defaultLocation = [51.1657, 10.4515];
            
            map = L.map('map').setView(defaultLocation, 6);

            // Add OpenStreetMap tiles
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19,
                crossOrigin: true
            }).addTo(map);

            // Initialize polyline for route
            routePath = L.polyline([], {
                color: '#667eea',
                weight: 4,
                opacity: 0.8
            }).addTo(map);

            // Try to get user's current location
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const pos = [position.coords.latitude, position.coords.longitude];
                        map.setView(pos, 15);
                        addCurrentLocationMarker(pos);
                    },
                    () => {
                        console.log('Error: The Geolocation service failed.');
                    }
                );
            }
        }

        // Add current location marker with pulsing effect
        function addCurrentLocationMarker(position) {
            if (currentMarker) {
                map.removeLayer(currentMarker);
            }

            const pulsingIcon = L.divIcon({
                className: 'pulsing-marker',
                iconSize: [30, 30],
                html: '<div style="width: 100%; height: 100%; background: #ee0979; border-radius: 50%; border: 3px solid white;"></div>'
            });

            currentMarker = L.marker(position, { icon: pulsingIcon }).addTo(map);
        }

        // Start recording
        async function startRecording() {
            if (!navigator.geolocation) {
                alert('Geolocation is not supported by your browser');
                return;
            }

            if (isRecording) {
                return;
            }

            try {
                await createSession();
            } catch (error) {
                console.error('Failed to initialize session:', error);
                alert('Failed to start recording:\n' + error.message);
                return;
            }

            isRecording = true;
            startTime = Date.now();
            gpsBatch = [];
            routeCoordinates = [];
            recordedPoints = [];
            totalDistance = 0;
            routePath.setLatLngs([]);

            // Update UI
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('saveBtn').disabled = true;
            document.getElementById('statusText').innerHTML = '<span class="recording-indicator"></span>Recording...';
            document.getElementById('pointsCount').textContent = '0';
            document.getElementById('distance').textContent = '0.00 km';

            // Enable voice recording button
            document.getElementById('voiceRecordBtn').disabled = false;

            // Try to initialize microphone (non-blocking)
            initMicrophone().catch(err => console.log('Microphone permission not granted yet'));

            // Start duration counter
            durationInterval = setInterval(updateDuration, 1000);

            // Start watching position
            watchId = navigator.geolocation.watchPosition(
                (position) => {
                    const timestampIso = new Date(position.timestamp || Date.now()).toISOString();
                    const speedKmh = position.coords.speed ? Number((position.coords.speed * 3.6).toFixed(2)) : null;
                    const point = {
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        altitude: position.coords.altitude ?? null,
                        accuracy: position.coords.accuracy ?? null,
                        speed: speedKmh,
                        heading: position.coords.heading ?? null,
                        timestamp: timestampIso,
                        source: 'web',
                    };

                    recordedPoints.push(point);
                    routeCoordinates.push([point.latitude, point.longitude]);
                    gpsBatch.push(point);
                    uploadGpsBatch(false);

                    // Update polyline
                    routePath.setLatLngs(routeCoordinates);

                    // Update current marker
                    addCurrentLocationMarker([point.latitude, point.longitude]);

                    // Center map on current position
                    map.panTo([point.latitude, point.longitude]);

                    // Calculate distance
                    if (routeCoordinates.length > 1) {
                        const lastPos = routeCoordinates[routeCoordinates.length - 2];
                        totalDistance += calculateDistance(
                            { lat: lastPos[0], lng: lastPos[1] },
                            { lat: point.latitude, lng: point.longitude }
                        );
                    }

                    // Update UI
                    document.getElementById('pointsCount').textContent = recordedPoints.length;
                    document.getElementById('distance').textContent = totalDistance.toFixed(2) + ' km';
                },
                (error) => {
                    console.error('Error getting position:', error);
                    alert('GPS Error: ' + error.message + '\nPlease allow location access.');
                },
                {
                    enableHighAccuracy: true,
                    timeout: 5000,
                    maximumAge: 0
                }
            );
        }

        // Stop recording
        async function stopRecording() {
            isRecording = false;

            if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }

            if (durationInterval) {
                clearInterval(durationInterval);
                durationInterval = null;
            }

            // Stop any ongoing voice recording
            if (isRecordingVoice) {
                stopVoiceRecording();
            }

            await uploadGpsBatch(true);

            // Update UI
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('saveBtn').disabled = false;
            document.getElementById('statusText').textContent = 'Stopped';
            document.getElementById('voiceRecordBtn').disabled = true;
        }

        // Save route
        async function saveRoute() {
            if (recordedPoints.length === 0) {
                alert('No route data to save!');
                return;
            }

            if (!sessionStartIso && !sessionId) {
                alert('Recording session not found. Please start a new recording.');
                return;
            }

            document.getElementById('statusText').textContent = 'Saving...';

            try {
                await uploadGpsBatch(true);

                let imageData = null;
                try {
                    const mapElement = document.getElementById('map-capture');
                    const canvas = await html2canvas(mapElement, {
                        useCORS: true,
                        allowTaint: true,
                        scale: 1.2,
                    });
                    imageData = canvas.toDataURL('image/jpeg', 0.7);
                } catch (error) {
                    console.warn('Map snapshot failed, continuing without preview:', error);
                }

                const result = await finishSession(imageData);

                document.getElementById('statusText').textContent = 'Saved Successfully!';
                alert('Route saved successfully!');
                resetRecorder();

                if (result?.summary?.route_id) {
                    if (confirm('Open route review?')) {
                        const reviewUrl = `${window.location.origin}/route-review/${result.summary.route_id}`;
                        window.open(reviewUrl, '_blank');
                    }
                }
            } catch (error) {
                console.error('Error saving route:', error);
                alert('Error saving route:\n' + (error.message || error));
                document.getElementById('statusText').textContent = 'Error Saving';
            }
        }

        // Reset recorder
        function resetRecorder() {
            routeCoordinates = [];
            recordedPoints = [];
            totalDistance = 0;
            routePath.setLatLngs([]);
            sessionId = null;
            sessionStartIso = null;
            startTime = null;
            gpsBatch = [];
            isRecording = false;

            // Reset voice notes
            voiceNotes.forEach(note => {
                if (note.audioUrl) {
                    URL.revokeObjectURL(note.audioUrl);
                }
            });
            voiceNotes = [];
            displayVoiceNotes();
            
            document.getElementById('pointsCount').textContent = '0';
            document.getElementById('distance').textContent = '0.00 km';
            document.getElementById('duration').textContent = '00:00:00';
            document.getElementById('statusText').textContent = 'Ready';
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('saveBtn').disabled = true;
            document.getElementById('voiceRecordBtn').disabled = true;
        }

        // Update duration display
        function updateDuration() {
            if (!startTime) return;
            
            const elapsed = Date.now() - startTime;
            const hours = Math.floor(elapsed / 3600000);
            const minutes = Math.floor((elapsed % 3600000) / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            
            const durationText = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            document.getElementById('duration').textContent = durationText;
        }

        // Calculate distance between two points (Haversine formula)
        function calculateDistance(pos1, pos2) {
            const R = 6371; // Earth's radius in km
            const dLat = toRad(pos2.lat - pos1.lat);
            const dLng = toRad(pos2.lng - pos1.lng);
            
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(toRad(pos1.lat)) * Math.cos(toRad(pos2.lat)) *
                      Math.sin(dLng / 2) * Math.sin(dLng / 2);
            
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        function toRad(degrees) {
            return degrees * Math.PI / 180;
        }

        // ========== Voice Notes Functions ==========

        // Initialize microphone
        async function initMicrophone() {
            try {
                microphoneStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                console.log('‚úÖ Microphone access granted');
                document.getElementById('micPermissionBanner').classList.remove('show');
                document.getElementById('voiceRecordBtn').disabled = false;
                return true;
            } catch (error) {
                console.error('‚ùå Microphone access denied:', error);
                document.getElementById('micPermissionBanner').classList.add('show');
                alert('Microphone access is required to record voice notes. Please allow microphone access in your browser settings.');
                return false;
            }
        }

        // Start voice note recording
        async function startVoiceRecording() {
            console.log('üé§ Attempting to start voice recording...');
            
            if (!microphoneStream) {
                console.log('Microphone stream not available, requesting permission...');
                const granted = await initMicrophone();
                if (!granted) {
                    console.log('Microphone permission denied');
                    return;
                }
            }

            audioChunks = [];
            
            try {
                // Check if MediaRecorder is supported
                if (!window.MediaRecorder) {
                    throw new Error('MediaRecorder is not supported in this browser');
                }

                mediaRecorder = new MediaRecorder(microphoneStream);
                console.log('MediaRecorder created, state:', mediaRecorder.state);
                
                mediaRecorder.ondataavailable = (event) => {
                    console.log('Audio data available:', event.data.size, 'bytes');
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onerror = (event) => {
                    console.error('MediaRecorder error:', event.error);
                    alert('Recording error: ' + event.error.message);
                };

                mediaRecorder.onstop = () => {
                    console.log('MediaRecorder stopped, audio chunks:', audioChunks.length);
                    saveVoiceNote();
                };

                mediaRecorder.start();
                isRecordingVoice = true;
                voiceRecordingStartTime = Date.now();

                // Update UI
                const btn = document.getElementById('voiceRecordBtn');
                btn.classList.remove('ready');
                btn.classList.add('recording');
                document.getElementById('voiceRecordIcon').textContent = '‚èπÔ∏è';
                document.getElementById('voiceRecordText').textContent = 'Stop Recording';
                document.getElementById('voiceTimer').style.display = 'inline-block';

                // Start timer
                voiceTimerInterval = setInterval(updateVoiceTimer, 1000);

                console.log('‚úÖ Voice recording started successfully');
            } catch (error) {
                console.error('‚ùå Error starting voice recording:', error);
                alert('Failed to start voice recording:\n' + error.message + '\n\nPlease make sure your browser supports audio recording and microphone access is allowed.');
            }
        }

        // Stop voice note recording
        function stopVoiceRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                isRecordingVoice = false;

                // Update UI
                const btn = document.getElementById('voiceRecordBtn');
                btn.classList.remove('recording');
                btn.classList.add('ready');
                document.getElementById('voiceRecordIcon').textContent = 'üé§';
                document.getElementById('voiceRecordText').textContent = 'Record Note';
                document.getElementById('voiceTimer').style.display = 'none';

                // Stop timer
                if (voiceTimerInterval) {
                    clearInterval(voiceTimerInterval);
                    voiceTimerInterval = null;
                }

                voiceRecordingStartTime = null;
                document.getElementById('voiceTimer').textContent = '0:00';

                console.log('‚èπÔ∏è Voice recording stopped');
            }
        }

        // Save voice note
        async function saveVoiceNote() {
            try {
                if (audioChunks.length === 0) {
                    console.warn('No audio data to save');
                    return;
                }

                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                audioChunks = [];

                let currentLocation = null;
                if (recordedPoints.length > 0) {
                    const latest = recordedPoints[recordedPoints.length - 1];
                    currentLocation = {
                        lat: latest.latitude,
                        lng: latest.longitude,
                    };
                }

                const timestampIso = new Date().toISOString();
                const durationMs = voiceRecordingStartTime ? (Date.now() - voiceRecordingStartTime) : null;

                try {
                    await uploadVoiceNoteBlob(audioBlob, currentLocation, timestampIso, durationMs ?? undefined);
                } catch (error) {
                    console.error('Voice note upload failed:', error);
                    alert('Failed to upload voice note: ' + error.message);
                    return;
                }

                const voiceNote = {
                    id: 'voice_' + Date.now(),
                    relativeMs: startTime ? Date.now() - startTime : 0,
                    timestampIso,
                    location: currentLocation,
                    duration: durationMs,
                    audioUrl: URL.createObjectURL(audioBlob),
                };

                voiceNotes.push(voiceNote);
                displayVoiceNotes();

                console.log('üíæ Voice note saved successfully. Total notes:', voiceNotes.length);

                const oldStatus = document.getElementById('statusText').innerHTML;
                document.getElementById('statusText').innerHTML = 'üé§ Voice note saved!';
                setTimeout(() => {
                    document.getElementById('statusText').innerHTML = oldStatus;
                }, 2000);
            } catch (error) {
                console.error('Error in saveVoiceNote:', error);
                alert('Failed to save voice note: ' + error.message);
            }
        }

        // Update voice recording timer
        function updateVoiceTimer() {
            if (!voiceRecordingStartTime) return;
            
            const elapsed = Math.floor((Date.now() - voiceRecordingStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            
            document.getElementById('voiceTimer').textContent = 
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        // Display voice notes
        function displayVoiceNotes() {
            const container = document.getElementById('voiceNotesList');
            
            if (voiceNotes.length === 0) {
                container.innerHTML = `
                    <div class="empty-voice-notes">
                        <div class="empty-voice-notes-icon">üéµ</div>
                        <p>No voice notes yet</p>
                        <p style="font-size: 0.9em;">Start recording to add voice notes at any point during your drive</p>
                    </div>
                `;
                document.getElementById('voiceNotesCount').textContent = '(0)';
                return;
            }

            container.innerHTML = '';
            
            voiceNotes.forEach((note, index) => {
                const noteDiv = document.createElement('div');
                noteDiv.className = 'voice-note-item';
                
                const timeStr = formatTimestamp(note.relativeMs || 0);
                const locationStr = (note.location && note.location.lat && note.location.lng) 
                    ? `üìç ${note.location.lat.toFixed(6)}, ${note.location.lng.toFixed(6)}`
                    : 'üìç No GPS location';

                noteDiv.innerHTML = `
                    <div class="voice-note-info">
                        <div class="voice-note-time">üé§ Note #${index + 1} - ${timeStr}</div>
                        <div class="voice-note-location">${locationStr}</div>
                    </div>
                    <div class="voice-note-actions">
                        <button class="voice-action-btn" onclick="playVoiceNote('${note.id}')">‚ñ∂Ô∏è Play</button>
                        <button class="voice-action-btn delete" onclick="deleteVoiceNote('${note.id}')">üóëÔ∏è Delete</button>
                    </div>
                `;
                
                container.appendChild(noteDiv);
            });

            document.getElementById('voiceNotesCount').textContent = `(${voiceNotes.length})`;
        }

        // Format timestamp (milliseconds to MM:SS)
        function formatTimestamp(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        // Play voice note
        window.playVoiceNote = function(noteId) {
            const note = voiceNotes.find(n => n.id === noteId);
            if (!note) return;

            if (!note.audioUrl) {
                alert('Audio file not available');
                return;
            }

            const audio = new Audio(note.audioUrl);
            audio.play().catch(error => {
                console.error('Error playing audio:', error);
                alert('Failed to play voice note');
            });
        };

        // Delete voice note
        window.deleteVoiceNote = function(noteId) {
            if (!confirm('Are you sure you want to delete this voice note?')) return;

            voiceNotes = voiceNotes.filter(n => {
                if (n.id === noteId && n.audioUrl) {
                    URL.revokeObjectURL(n.audioUrl);
                }
                return n.id !== noteId;
            });
            displayVoiceNotes();
            console.log('üóëÔ∏è Voice note deleted:', noteId);
        };

        // Toggle voice recording
        function toggleVoiceRecording() {
            if (!sessionId) {
                alert('Start recording the route before adding a voice note.');
                return;
            }
            if (isRecordingVoice) {
                stopVoiceRecording();
            } else {
                startVoiceRecording();
            }
        }

        // ========== End Voice Notes Functions ==========

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', startRecording);
        document.getElementById('stopBtn').addEventListener('click', stopRecording);
        document.getElementById('saveBtn').addEventListener('click', saveRoute);
        document.getElementById('voiceRecordBtn').addEventListener('click', toggleVoiceRecording);

        // Initialize map on load
        window.onload = initMap;
    </script>
</body>
</html>
